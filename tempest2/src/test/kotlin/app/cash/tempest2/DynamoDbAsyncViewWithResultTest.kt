/*
 * Copyright 2021 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app.cash.tempest2

import app.cash.tempest2.extensions.WithResultExtension
import app.cash.tempest2.extensions.WithResultExtension.Companion.WithResultExtensionInstalledLast
import app.cash.tempest2.musiclibrary.testDb
import app.cash.tempest2.musiclibrary.versionedattribute.AsyncVersionedAttributeDb
import app.cash.tempest2.musiclibrary.versionedattribute.ParallelVersionedAttribute
import app.cash.tempest2.musiclibrary.versionedattribute.VersionedAttribute
import app.cash.tempest2.testing.asyncLogicalDb
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.asCoroutineDispatcher
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.time.delay
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.extension.RegisterExtension
import software.amazon.awssdk.enhanced.dynamodb.Expression
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension
import software.amazon.awssdk.enhanced.dynamodb.internal.client.ExtensionResolver.defaultExtensions
import software.amazon.awssdk.services.dynamodb.model.ConditionalCheckFailedException
import java.time.Instant
import java.util.concurrent.Executors
import kotlin.random.Random
import kotlin.time.Duration.Companion.hours
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.minutes
import kotlin.time.toJavaDuration

@OptIn(WithResultExtensionInstalledLast::class)
class DynamoDbAsyncViewWithResultTest {

  @RegisterExtension
  @JvmField
  val db = testDb()

  private val multiThreadedCoroutineDispatcher = Executors.newFixedThreadPool(20).asCoroutineDispatcher()

  private val fakeClock = FakeClock(1.minutes)

  private val autoGeneratedTimestampRecordExtension =
    AutoGeneratedTimestampRecordExtension.builder().baseClock(fakeClock).build()

  private val versionedAttributeTable by lazy {
    db.asyncLogicalDb<AsyncVersionedAttributeDb>(
      defaultExtensions() + autoGeneratedTimestampRecordExtension + WithResultExtension.create()
    ).versionedAttributes
  }

  private val versionedAttributeTableWithoutExtension by lazy {
    db.asyncLogicalDb<AsyncVersionedAttributeDb>(
      defaultExtensions() + autoGeneratedTimestampRecordExtension
    ).versionedAttributes
  }

  @Test
  fun saveAndVerifyResult() = runBlocking(multiThreadedCoroutineDispatcher) {
    async {
    val item = VersionedAttribute(
      partition_key = "item_one",
      description = "one of the items",
      created_at = fakeClock.getInstant()
    )

      fakeClock.add(1.hours)


    val result = versionedAttributeTable.attributes.saveWithResult(item)
    assertThat(result).isEqualTo(
      item.copy(
        version = 1L,
        updated_at = fakeClock.getInstant()
      )
    )
    println(result)

      fakeClock.add(1.hours)

    val updatedDescription = result.copy(
      description = "a new name for the item"
    )

    val updatedResult = versionedAttributeTable.attributes.saveWithResult(updatedDescription)
    assertThat(updatedResult).isEqualTo(
      updatedDescription.copy(
        version = 2L,
        updated_at = fakeClock.getInstant()
      )
    )
    println(updatedResult)
    }.await()
  }

  @Test
  fun parallelSaveWithResult() = runBlocking(multiThreadedCoroutineDispatcher) {
    // Create 1,000 items and write them in parallel.
    // The number of updates is based on % 5 of the index.
    // 0 = 1 write, 1 = 2 writes, etc.
    // Each write we:
    // - append the lastest version to the description.
    // - Record the previous version and timestamps in fields.
    val items = (0..1000).map { index ->
      async {
        // Add some randomness to start times so the steps are mixed between items.
        delay(Random.nextInt(0, 1000).milliseconds.toJavaDuration())

        val mod = index % 5
        index.printThreadInfo(0.0)
        val one = versionedAttributeTable.parallelAttributes.saveWithResult(
          ParallelVersionedAttribute(
            partition_key = "item_$index",
            description = "$index",
            created_at = fakeClock.instant()
          )
        )

        index.printThreadInfo(1.0)
        assertThat(versionedAttributeTable.parallelAttributes.load(one.key)).isEqualTo(one)
        index.printThreadInfo(1.5)

        if (mod < 1) {
          return@async one
        }

        val two = versionedAttributeTable.parallelAttributes.saveWithResult(
          one.copy(
            description = one.description + ":${one.version}",
            one_version = one.version!!,
            one_created_at = one.created_at!!,
            one_updated_at = one.updated_at!!,
          )
        )

        index.printThreadInfo(2.0)
        assertThat(versionedAttributeTable.parallelAttributes.load(two.key)).isEqualTo(two)
        index.printThreadInfo(2.5)

        if (mod < 2) {
          return@async two
        }

        val three = versionedAttributeTable.parallelAttributes.saveWithResult(
          two.copy(
            description = two.description + ":${two.version}",
            two_version = two.version!!,
            two_created_at = two.created_at!!,
            two_updated_at = two.updated_at!!,
          )
        )

        index.printThreadInfo(3.0)
        assertThat(versionedAttributeTable.parallelAttributes.load(three.key)).isEqualTo(three)
        index.printThreadInfo(3.5)

        if (mod < 3) {
          return@async three
        }

        val four = versionedAttributeTable.parallelAttributes.saveWithResult(
          three.copy(
            description = three.description + ":${three.version}",
            three_version = three.version!!,
            three_created_at = three.created_at!!,
            three_updated_at = three.updated_at!!,
          )
        )

        index.printThreadInfo(4.0)
        assertThat(versionedAttributeTable.parallelAttributes.load(four.key)).isEqualTo(four)
        index.printThreadInfo(4.5)

        if (mod < 4) {
          return@async four
        }

        val five = versionedAttributeTable.parallelAttributes.saveWithResult(
          four.copy(
            description = four.description + ":${four.version}",
            four_version = four.version!!,
            four_created_at = four.created_at!!,
            four_updated_at = four.updated_at!!,
          )
        )

        index.printThreadInfo(5.0)
        assertThat(versionedAttributeTable.parallelAttributes.load(five.key)).isEqualTo(five)
        index.printThreadInfo(5.5)

        return@async five
      }
    }.awaitAll()

    // Track the timestamps we've seen, there should be no duplicates since FakeClock increments when read.
    val seenUpdatedAts: MutableList<Instant> = mutableListOf()

    items.forEach {
      val descriptionParts = it.description.split(":").map(String::toInt)
      val index = descriptionParts[0]
      val expectedVersion = 1L + (index % 5)

      // print the sample of the items we logged thread info for.
      index.printItem(it)

      assertThat(descriptionParts.size).isEqualTo(expectedVersion)
      assertThat(it.version).isEqualTo(expectedVersion)
      assertThat(it.partition_key).isEqualTo("item_$index")

      // Based on the expected version from the index validate the fields.
      if (expectedVersion == 1L) {
        // No updates.  With Dynamo behavior created_at and updated_at wont match.
        assertThat(it.updated_at).isAfter(it.created_at)
        assertThat(it.one_version).isNull()
        assertThat(it.one_created_at).isNull()
        assertThat(it.one_updated_at).isNull()
        seenUpdatedAts.add(it.created_at!!)

        return@forEach
      }

      seenUpdatedAts.add(it.updated_at!!)

      if (expectedVersion >= 2L) {
        // all other version should have updated_at before the current version
        // and created_at equal to the latest.
        assertThat(descriptionParts[1]).isEqualTo(1)
        assertThat(it.one_version).isEqualTo(1)
        assertThat(it.one_created_at).isEqualTo(it.created_at)
        assertThat(it.one_updated_at).isAfter(it.one_created_at)
        assertThat(it.one_updated_at).isBefore(it.updated_at)
        seenUpdatedAts.add(it.one_updated_at!!)
      }

      if (expectedVersion >= 3L) {
        // version n should have updated_at after version n-1
        assertThat(descriptionParts[2]).isEqualTo(2)
        assertThat(it.two_version).isEqualTo(2)
        assertThat(it.two_created_at).isEqualTo(it.created_at)
        assertThat(it.two_updated_at).isBefore(it.updated_at)
        assertThat(it.two_updated_at).isAfter(it.one_updated_at)
        seenUpdatedAts.add(it.two_updated_at!!)
      }

      if (expectedVersion >= 4L) {
        assertThat(descriptionParts[3]).isEqualTo(3)
        assertThat(it.three_version).isEqualTo(3)
        assertThat(it.three_created_at).isEqualTo(it.created_at)
        assertThat(it.three_updated_at).isBefore(it.updated_at)
        assertThat(it.three_updated_at).isAfter(it.two_updated_at)
        seenUpdatedAts.add(it.three_updated_at!!)
      }

      if (expectedVersion == 5L) {
        assertThat(descriptionParts[4]).isEqualTo(4)
        assertThat(it.four_version).isEqualTo(4)
        assertThat(it.four_created_at).isEqualTo(it.created_at)
        assertThat(it.four_updated_at).isBefore(it.updated_at)
        assertThat(it.four_updated_at).isAfter(it.three_updated_at)
        seenUpdatedAts.add(it.four_updated_at!!)
      }
    }

    // Verify that we didn't see any duplicate timestamps.
    assertThat(seenUpdatedAts.distinct().sorted()).isEqualTo(seenUpdatedAts.sorted())
    Unit
  }

  private suspend fun CoroutineScope.saveAsync(item: ParallelVersionedAttribute): Deferred<ParallelVersionedAttribute> =
    async {
      versionedAttributeTable.parallelAttributes.saveWithResult(item)
    }

  private suspend fun Int.printThreadInfo(sequence: Double) {
    if (this in 595..599) {
      println("$this-$sequence: ${Instant.now().toEpochMilli()}: ${Thread.currentThread().name}")
    }
  }

  private suspend fun Int.printItem(parallelVersionedAttribute: ParallelVersionedAttribute) {
    if (this in 595..599) {
      println(parallelVersionedAttribute.toString().split(",", "(", ")").joinToString("\n  "))
    }
  }

  @Test
  fun saveIfNotExist() = runBlockingTest {
    val item = VersionedAttribute(
      partition_key = "item_one",
      description = "one of the items",
      created_at = fakeClock.getInstant()
    )

    fakeClock.add(1.hours)

    val result = versionedAttributeTable.attributes.saveWithResult(item)
    assertThat(WithResultExtension.inMemoryItemsResult.get()).isNull()
    assertThat(result).isEqualTo(
      item.copy(
        version = 1L,
        updated_at = fakeClock.getInstant()
      )
    )
    println(result)

    fakeClock.add(1.hours)

    val updatedDescription = result.copy(
      description = "a new name for the item"
    )

    // This fails because the item already exists.
    assertThrows<ConditionalCheckFailedException> {
      versionedAttributeTable.attributes.saveWithResult(updatedDescription, ifNotExist())
    }

    assertThat(WithResultExtension.inMemoryItemsResult.get()).isNull()
  }

  @Test
  fun optimisticLocking() = runBlockingTest {
    val item = VersionedAttribute(
      partition_key = "item_one",
      description = "one of the items",
      created_at = fakeClock.getInstant()
    )

    fakeClock.add(1.hours)

    val result = versionedAttributeTable.attributes.saveWithResult(item)
    assertThat(WithResultExtension.inMemoryItemsResult.get()).isNull()
    assertThat(result).isEqualTo(
      item.copy(
        version = 1L,
        updated_at = fakeClock.getInstant()
      )
    )
    println(result)

    // This fails because the version is not updated.
    assertThrows<ConditionalCheckFailedException> {
      versionedAttributeTable.attributes.saveWithResult(item)
    }

    assertThat(WithResultExtension.inMemoryItemsResult.get()).isNull()
  }

  @Test
  fun failsIfExtensionNotInstalled() = runBlockingTest {
    val item = VersionedAttribute(
      partition_key = "item_one",
      description = "one of the items",
      created_at = fakeClock.getInstant()
    )

    fakeClock.add(1.hours)

    val ex = assertThrows<IllegalStateException> {
      versionedAttributeTableWithoutExtension.attributes.saveWithResult(item)
    }

    assertThat(ex).hasMessageContaining("Resulting Item was not updated. Did you forget to install the ApplyUpdatesExtension?")
  }

  private fun ifNotExist(): Expression {
    return Expression.builder()
      .expression("attribute_not_exists(partition_key)")
      .build()
  }
}
