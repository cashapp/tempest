package app.cash.tempest2.extensions

import app.cash.tempest2.extensions.WriteMode.CREATE
import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter
import software.amazon.awssdk.enhanced.dynamodb.AttributeValueType
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClientExtension
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbExtensionContext
import software.amazon.awssdk.enhanced.dynamodb.EnhancedType
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension
import software.amazon.awssdk.enhanced.dynamodb.extensions.WriteModification
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticAttributeTag
import software.amazon.awssdk.enhanced.dynamodb.mapper.StaticTableMetadata
import java.time.Clock
import java.time.Instant
import java.util.Date
import java.util.function.Consumer

/**
 * An extension that automatically sets timestamps on fields annotated with [TempestAutoGeneratedTimeStamp]
 * supporting both created at and updated at timestamps.  Additionally, supports [Date] types.
 * Usage of [Date] type requires installing [TempestDateAttributeConverterProvider] on your [DynamoDbBean] or [TempestDateAttributeConverter]
 * on each attribute.  You may also implement a custom converter.
 *
 * This implementation is a port of [AutoGeneratedTimestampRecordExtension]
 */
@Suppress("UNCHECKED_CAST")
class TempestAutoGeneratedTimestampRecordExtension private constructor(private val clock: Clock = Clock.systemUTC()) :
  DynamoDbEnhancedClientExtension {

  override fun beforeWrite(context: DynamoDbExtensionContext.BeforeWrite): WriteModification {
    // Capture the clock so all updates have the same timestamp.
    val instantNow = clock.instant()
    val customMetadataObject: Collection<TempestAutoGeneratedTimestampMetadata> =
      (context.tableMetadata().customMetadataObject(CUSTOM_METADATA_KEY, Collection::class.java).orElse(null)
        ?: return WriteModification.builder().build()) as Collection<TempestAutoGeneratedTimestampMetadata>

    val itemToTransform = context.items().toMutableMap()
    customMetadataObject.forEach {
      val currentValue = context.items().get(it.attributeName)
      if (it.writeMode == CREATE && currentValue != null) {
        // Create mode with a value already set, skip this item.
        return@forEach
      }

      // Convert the current timestamp to the correct type and then convert to an Attribute utilizing the
      // table schema's converters.
      val converterForAttribute = context.tableSchema().converterForAttribute(it.attributeName)
      val attributeValue = when (it.rawType) {
        Instant::class.java -> (converterForAttribute as AttributeConverter<Instant>).transformFrom(instantNow)
        Date::class.java -> (converterForAttribute as AttributeConverter<Date>).transformFrom(Date.from(instantNow))
        else -> throw IllegalStateException("Unsupported attribute type")
      }

      // Put or replace the previous value with the new value.
      itemToTransform.put(it.attributeName, attributeValue)
    }

    return WriteModification.builder().transformedItem(itemToTransform).build()
  }

  companion object {
    fun create(clock: Clock): TempestAutoGeneratedTimestampRecordExtension {
      return TempestAutoGeneratedTimestampRecordExtension(clock)
    }

    fun create(): TempestAutoGeneratedTimestampRecordExtension {
      return TempestAutoGeneratedTimestampRecordExtension(Clock.systemUTC())
    }

    internal class AttributeTag {
      companion object {
        @Suppress("UNUSED_PARAMETER")
        @JvmStatic
        fun attributeTagFor(annotation: TempestAutoGeneratedTimeStamp): StaticAttributeTag {
          return TempestAutoGeneratedTimestampAttribute(annotation.writeMode)
        }
      }
    }

    private val CUSTOM_METADATA_KEY =
      "TempestAutoGeneratedCreatedAtTimestampRecordExtension:TempestAutoGeneratedCreatedAtTimestampAttribute";

    data class TempestAutoGeneratedTimestampMetadata(
      val writeMode: WriteMode,
      val rawType: Class<*>,
      val attributeName: String
    )

    private class TempestAutoGeneratedTimestampAttribute(
      val writeMode: WriteMode,
    ) : StaticAttributeTag {

      lateinit var rawType: Class<*>

      override fun <R> validateType(
        attributeName: String?, type: EnhancedType<R>, attributeValueType: AttributeValueType
      ) {
        checkNotNull(type) { "type is null" }
        checkNotNull(type.rawClass()) { "rawClass is null" }
        checkNotNull(attributeValueType) { "attributeValueType is null" }

        check(type.rawClass() == Instant::class.java || type.rawClass() == Date::class.java) {
          """
        Attribute '$attributeName' of Class type ${type.rawClass()} is not a suitable Java Class type to be used as a Auto Generated
        CreatedAt attribute. Only java.time.Instant or java.util.Date Class type is supported.
    """.trimIndent()
        }

        rawType = type.rawClass()!!
      }

      override fun modifyMetadata(
        attributeName: String, attributeValueType: AttributeValueType?
      ): Consumer<StaticTableMetadata.Builder> {
        return Consumer { metadata: StaticTableMetadata.Builder ->
          metadata.addCustomMetadataObject(
            TempestAutoGeneratedTimestampRecordExtension.CUSTOM_METADATA_KEY, setOf<Any>(
              TempestAutoGeneratedTimestampMetadata(
                writeMode = writeMode, rawType = rawType, attributeName = attributeName
              )
            )
          ).markAttributeAsKey(attributeName, attributeValueType)
        }
      }
    }
  }
}